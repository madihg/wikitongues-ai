import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

function csvEscape(value: string | number | null | undefined): string {
  if (value === null || value === undefined) return "";
  const str = String(value);
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function csvRow(values: (string | number | null | undefined)[]): string {
  return values.map(csvEscape).join(",");
}

async function exportPairwise(): Promise<string> {
  const data = await prisma.pairwiseComparison.findMany({
    include: {
      modelOutputA: { select: { model: true, modelId: true } },
      modelOutputB: { select: { model: true, modelId: true } },
      annotator: { select: { name: true, email: true } },
    },
    orderBy: { createdAt: "asc" },
  });

  const header = csvRow([
    "id",
    "promptId",
    "modelA",
    "modelAId",
    "modelB",
    "modelBId",
    "winner",
    "explanation",
    "annotator",
    "createdAt",
  ]);

  const rows = data.map((row) =>
    csvRow([
      row.id,
      row.promptId,
      row.modelOutputA.model,
      row.modelOutputA.modelId,
      row.modelOutputB.model,
      row.modelOutputB.modelId,
      row.winner,
      row.explanation,
      row.annotator.name ?? row.annotator.email,
      row.createdAt.toISOString(),
    ]),
  );

  return [header, ...rows].join("\n");
}

async function exportRubric(): Promise<string> {
  const data = await prisma.rubricScore.findMany({
    include: {
      modelOutput: { select: { model: true, modelId: true } },
      annotator: { select: { name: true, email: true } },
    },
    orderBy: { createdAt: "asc" },
  });

  const header = csvRow([
    "id",
    "promptId",
    "model",
    "modelId",
    "culturalAccuracy",
    "linguisticAuthenticity",
    "creativeDepth",
    "factualCorrectness",
    "notesCulturalAccuracy",
    "notesLinguisticAuthenticity",
    "notesCreativeDepth",
    "notesFactualCorrectness",
    "annotator",
    "createdAt",
  ]);

  const rows = data.map((row) =>
    csvRow([
      row.id,
      row.promptId,
      row.modelOutput.model,
      row.modelOutput.modelId,
      row.culturalAccuracy,
      row.linguisticAuthenticity,
      row.creativeDepth,
      row.factualCorrectness,
      row.notesCulturalAccuracy,
      row.notesLinguisticAuthenticity,
      row.notesCreativeDepth,
      row.notesFactualCorrectness,
      row.annotator.name ?? row.annotator.email,
      row.createdAt.toISOString(),
    ]),
  );

  return [header, ...rows].join("\n");
}

async function exportReport(): Promise<string> {
  const [promptCount, modelOutputCount, pairwiseCount, rubricCount, gapCount] =
    await Promise.all([
      prisma.prompt.count(),
      prisma.modelOutput.count(),
      prisma.pairwiseComparison.count(),
      prisma.rubricScore.count(),
      prisma.handoffItem.count({ where: { gapCategory: { not: null } } }),
    ]);

  const languages = await prisma.prompt.findMany({
    select: { language: true },
    distinct: ["language"],
  });

  const models = await prisma.modelOutput.findMany({
    select: { model: true },
    distinct: ["model"],
  });

  const resolvedGaps = await prisma.handoffItem.count({
    where: {
      gapCategory: { not: null },
      status: { in: ["approved", "corrected"] },
    },
  });

  const lines = [
    "# Wikitongues AI Benchmark Report",
    "",
    `**Generated:** ${new Date().toISOString()}`,
    "",
    "## Overview",
    "",
    `- **Languages:** ${languages.map((l) => l.language).join(", ") || "None"}`,
    `- **Models evaluated:** ${models.map((m) => m.model).join(", ") || "None"}`,
    `- **Total prompts:** ${promptCount}`,
    `- **Model outputs:** ${modelOutputCount}`,
    `- **Pairwise comparisons:** ${pairwiseCount}`,
    `- **Rubric scores:** ${rubricCount}`,
    "",
    "## Gap Analysis",
    "",
    `- **Total gaps identified:** ${gapCount}`,
    `- **Gaps resolved:** ${resolvedGaps}`,
    `- **Gaps remaining:** ${gapCount - resolvedGaps}`,
    "",
    "---",
    "",
    "*Report generated by Wikitongues AI admin dashboard.*",
  ];

  return lines.join("\n");
}

export async function GET(
  _req: Request,
  { params }: { params: Promise<{ type: string }> },
) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "RESEARCHER") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { type } = await params;

  switch (type) {
    case "pairwise": {
      const csv = await exportPairwise();
      return new NextResponse(csv, {
        headers: {
          "Content-Type": "text/csv",
          "Content-Disposition":
            'attachment; filename="pairwise_comparisons.csv"',
        },
      });
    }
    case "rubric": {
      const csv = await exportRubric();
      return new NextResponse(csv, {
        headers: {
          "Content-Type": "text/csv",
          "Content-Disposition": 'attachment; filename="rubric_scores.csv"',
        },
      });
    }
    case "report": {
      const md = await exportReport();
      return new NextResponse(md, {
        headers: {
          "Content-Type": "text/markdown",
          "Content-Disposition": 'attachment; filename="benchmark_report.md"',
        },
      });
    }
    default:
      return NextResponse.json(
        { error: "Invalid export type. Use: pairwise, rubric, or report" },
        { status: 400 },
      );
  }
}
