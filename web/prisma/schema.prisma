generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

// pgvector extension for embedding similarity search
// If not available, RAG falls back to keyword search

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

enum UserRole {
  LEARNER
  ANNOTATOR
  RESEARCHER
}

enum DifficultyLevel {
  basic
  intermediate
  advanced
}

enum PromptCategory {
  real_world_use
  words_concepts
  frontier_aspirations
  abstract_vs_everyday
}

enum HandoffStatus {
  pending
  in_review
  approved
  corrected
  rejected
}

enum GapCategory {
  missing_vocabulary
  missing_cultural_context
  missing_dialect_knowledge
  missing_translation_pair
}

enum VerificationStatus {
  seed
  single_annotator
  multi_annotator_verified
  expert_reviewed
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String
  role         UserRole @default(ANNOTATOR)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  languages           AnnotatorLanguage[]
  pairwiseComparisons PairwiseComparison[]
  rubricScores        RubricScore[]
  handoffReviews      HandoffItem[]        @relation("ReviewedBy")
  promptsCreated      Prompt[]             @relation("CreatedBy")
  promptsEdited       PromptEdit[]
}

model AnnotatorLanguage {
  id             String @id @default(cuid())
  userId         String
  language       String
  expertiseLevel String // native, fluent, conversational

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, language])
}

model Prompt {
  id                     String          @id @default(cuid())
  promptId               String          @unique // e.g. ig_rw_001
  category               PromptCategory
  language               String
  text                   String
  sourceLanguage         String?
  targetCulture          String?
  expectedCulturalContext String?
  difficultyLevel        DifficultyLevel @default(intermediate)
  createdById            String?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt

  createdBy    User?         @relation("CreatedBy", fields: [createdById], references: [id])
  edits        PromptEdit[]
  modelOutputs ModelOutput[]
}

model PromptEdit {
  id        String   @id @default(cuid())
  promptId  String
  userId    String
  fieldName String
  oldValue  String?
  newValue  String
  createdAt DateTime @default(now())

  prompt Prompt @relation(fields: [promptId], references: [id])
  user   User   @relation(fields: [userId], references: [id])
}

model ModelOutput {
  id            String   @id @default(cuid())
  promptId      String
  model         String   // claude, chatgpt, gemini, gemma
  modelId       String   // full model ID e.g. claude-sonnet-4-5-20250929
  outputText    String
  tokenCountIn  Int?
  tokenCountOut Int?
  latencyMs     Int?
  epochId       String?
  runId         String?
  createdAt     DateTime @default(now())

  prompt       Prompt               @relation(fields: [promptId], references: [id])
  epoch        Epoch?               @relation(fields: [epochId], references: [id])
  pairwiseAsA  PairwiseComparison[] @relation("ModelA")
  pairwiseAsB  PairwiseComparison[] @relation("ModelB")
  rubricScores RubricScore[]
}

model PairwiseComparison {
  id             String   @id @default(cuid())
  promptId       String   // references Prompt.promptId for easy lookup
  modelOutputAId String
  modelOutputBId String
  winner         String   // "a" or "b"
  explanation    String
  annotatorId    String
  epochId        String?
  createdAt      DateTime @default(now())

  modelOutputA ModelOutput @relation("ModelA", fields: [modelOutputAId], references: [id])
  modelOutputB ModelOutput @relation("ModelB", fields: [modelOutputBId], references: [id])
  annotator    User        @relation(fields: [annotatorId], references: [id])
  epoch        Epoch?      @relation(fields: [epochId], references: [id])
}

model RubricScore {
  id                          String   @id @default(cuid())
  promptId                    String
  modelOutputId               String
  culturalAccuracy            Int      // 1-5
  linguisticAuthenticity      Int      // 1-5
  creativeDepth               Int      // 1-5
  factualCorrectness          Int      // 1-5
  notesCulturalAccuracy       String?
  notesLinguisticAuthenticity String?
  notesCreativeDepth          String?
  notesFactualCorrectness     String?
  annotatorId                 String
  epochId                     String?
  createdAt                   DateTime @default(now())

  modelOutput ModelOutput @relation(fields: [modelOutputId], references: [id])
  annotator   User        @relation(fields: [annotatorId], references: [id])
  epoch       Epoch?      @relation(fields: [epochId], references: [id])
}

model HandoffItem {
  id                 String             @id @default(cuid())
  learnerRequest     String
  modelAnswer        String
  confidenceScore    Float
  reviewerReasoning  String?
  gapCategory        GapCategory?
  status             HandoffStatus      @default(pending)
  correctedAnswer    String?
  reviewerId         String?
  verificationStatus VerificationStatus @default(seed)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  reviewedAt         DateTime?

  pipelineRunId String?      @unique
  reviewer      User?        @relation("ReviewedBy", fields: [reviewerId], references: [id])
  pipelineRun   PipelineRun? @relation(fields: [pipelineRunId], references: [id])
}

model Epoch {
  id                     String    @id @default(cuid())
  epochNumber            Int
  language               String
  trigger                String    // manual, correction_threshold, scheduled
  ragSnapshotId          String?
  promptCatalogueVersion String?
  startedAt              DateTime  @default(now())
  completedAt            DateTime?
  notes                  String?

  modelOutputs        ModelOutput[]
  pairwiseComparisons PairwiseComparison[]
  rubricScores        RubricScore[]

  @@unique([epochNumber, language])
}

// ─── Phase C: Conversational AI ──────────────────────────────

model Conversation {
  id        String   @id @default(cuid())
  learnerId String?
  language  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[]
}

model Message {
  id              String   @id @default(cuid())
  conversationId  String
  role            String
  content         String
  source          String
  confidenceScore Float?
  pipelineRunId   String?  @unique
  createdAt       DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id])
  pipelineRun  PipelineRun? @relation
}

model PipelineRun {
  id                  String   @id @default(cuid())
  messageId           String   @unique
  translatorModel     String
  translatorOutput    String
  translatorLatencyMs Int?
  reviewerOutput      String?
  reviewerConfidence  Float?
  reviewerReasoning   String?
  ragContextIds       String[]
  retryCount          Int      @default(0)
  finalDisposition    String
  gapCategory         String?
  createdAt           DateTime @default(now())

  message     Message      @relation(fields: [messageId], references: [id])
  handoffItem HandoffItem?
}

model RagEntry {
  id                 String                         @id @default(cuid())
  language           String
  chunkType          String
  topic              String
  content            String
  source             String
  verificationStatus String                         @default("seed")
  annotatorId        String?
  embedding          Unsupported("vector(1536)")?
  createdAt          DateTime                       @default(now())
  updatedAt          DateTime                       @updatedAt

  history RagEntryHistory[]
}

model RagEntryHistory {
  id         String   @id @default(cuid())
  ragEntryId String
  content    String
  editedById String?
  reason     String?
  createdAt  DateTime @default(now())

  ragEntry RagEntry @relation(fields: [ragEntryId], references: [id])
}
